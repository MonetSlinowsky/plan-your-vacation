package c4_5;


import java.util.ArrayList;
import java.util.Iterator;

/*****
 * 
 * @author monet
 * This is a static class with a bunch of private helper functions that allow the gainRatio of an attribute 
 * to be calculated
 * The gain ratio is calculated for textAttributeX
 * The Attribute target is the clasifier attribute (we want to use the decision tree to classify cases to 
 * a value of this attribute)
 *
 */

public class gainRatioCalc {
	
	
	public static double getGainRatio(Attribute target, Attribute testAttributeX, ArrayList<Case> dataList, int print1) {
		/*
		 * Finds the gain ratio (information gained) by splitting the cases in dataList based on the
		 * attribute testAttributeX
		 * Input: target-> attribute the data is being classified on
		 *        testAttributeX-> an attribute that is NOT the target attribute
		 *        dataList-> list of training data cases
		 *Output: the gain ratio of testAttributeX
		 */
		
		
		if(print1==1) {
		System.out.println("");
		System.out.println("Now calculating the gain ratio for " +testAttributeX.getAName());
		}
		
		
		double g= findGainOfAttribute(target, testAttributeX, dataList, print1);
		double s=findSplitInfoX(testAttributeX, dataList, print1);
	
		
		if(dataList.isEmpty()){
			System.out.println("NO DATA");
			System.exit(0);
		}
		
		if(s==0) {
			//If this happens, the info and infoX of the set are the same. This means all the attribute values 
			//are the same so this data should not be further subdivided. 
			return 1;
			}
		
		double r=g/s;
		
		if(print1==1) {
			System.out.println("Gain ratio is: " +r);
			System.out.println("");
			System.out.println("--------------------------");
		}
		return r;
	}



	private static double findSplitInfoX(Attribute testAttributeX, ArrayList<Case> dataList, int print1) {
		/*
		 * Finds the split info(X), which represents the information generated by dividing T into n subsets 
		 * (where n is the number of possible outcomes of testAttributeX)
		 */
		
		double splitInfo=0;

		//For every outcome of testAttribute X (ex. if testAttributeX is trip type outcomes are 1, 2, 3, 4,5)
				Iterator<String> itOutcome=testAttributeX.getPossibleValues().iterator();
				while(itOutcome.hasNext()) {
				
					String thisOutcome=itOutcome.next();
					
					//Count the cases that would be in the subset
					double count=Count(dataList, testAttributeX, thisOutcome);
					

					//Find count/total_number_of_cases
					//Add that value*log2(that value) to split info
					if(count==0) {continue;}
					
						double denominator=(double) dataList.size();
						double ratio=count/denominator;
						splitInfo=splitInfo - (ratio*log2(ratio));
					
				}//while
				
				if(print1==1) {
				System.out.println("SplitInfo is " + splitInfo + " for " +testAttributeX.getAName());
				System.out.println(" ");
				}

		return splitInfo;
	}
	
	private static double findGainOfAttribute(Attribute target, Attribute testAttributeX, ArrayList<Case> dataList, int print1) {
		
		
		double infoOfSet= findInfoOfSet(target, dataList);
		double infoX=findInfoX(target, testAttributeX, dataList);

		
		double rslt=infoOfSet-infoX;
		if(print1==1) {
			System.out.println("Gain is " +rslt + " for " + testAttributeX.getAName());
		}
		return rslt;
	}
	
	private static double findInfoX(Attribute target, Attribute testAttributeX, ArrayList<Case> dataList) {
		
		double infoX=0;
		
		//For every outcome of testAttribute X (ex. if testAttributeX is trip type outcomes are 1, 2, 3, 4,5)
		Iterator<String> itOutcome=testAttributeX.getPossibleValues().iterator();
		while(itOutcome.hasNext()) {
		
			String thisOutcome=itOutcome.next();
			
			//System.out.println("The outcome we are looking at of " + testAttributeX.getAName() + " is " +thisOutcome);
			//Get the subset of data with that outcome
			ArrayList<Case> subsetWithOutcome=new ArrayList<Case>();
			
			dataList.forEach((c) -> { 
				if(c.getValue(testAttributeX.getAName()).equals(thisOutcome)) {
				subsetWithOutcome.add(c);
			}});
			
			//Find info(subset)
			double info;
			if(!(subsetWithOutcome.isEmpty())) {
			info=findInfoOfSet(target, subsetWithOutcome);
			}
			
			else {
				info=0;
			}
			//Multiply info(subset) by (size of subset)/(all data)
			//Add that value to infox
			double sizeR=(double)subsetWithOutcome.size()/(double)dataList.size();
			infoX=infoX + info*sizeR;
			
		}//while
		
		return infoX; 
	}
	
	private static double findInfoOfSet(Attribute target, ArrayList<Case> dataList) {
		/*
		 * Input: target the attribute that data is classified by ("reccomend"
		 * dataList: list of cases in this subset
		 * 
		 * Output: info= -sum(freq(Ci,S)/|S| *logs(freq(Ci,S)/S)
		 */
		double info=0;
		
		Iterator<String> attVals=target.getPossibleValues().iterator();
		
		while(attVals.hasNext()) {
		
		//Find the frequency ratio
		double freqR=findFreqRatio(dataList, attVals.next(), target);
		
		//Add to info
		if(freqR==0) {
			continue;
		}
		
		else {
			info=info - (freqR*log2(freqR));
		}
		
		}
	

		return info;
	}
	
	private static double log2(double x) {
		/*
		 * Gives log2(x)
		 */
		
		return (Math.log10(x))/(Math.log10(2));
	}
	
	private static double findFreqRatio(ArrayList<Case> dataList, String Ci, Attribute target) {
		/*
		 * Gives freq(Ci, S)/|S|
		 * 
		 * Input: Ci-> the name of the class we are counting, it should be a value of the attribute with the name target
		 *        target -> the name of an attribute from the attributeList
		 *        I.e. Target is "reccomend" so Ci is either "yes" or "no"
		 */
		
		double count=Count(dataList, target, Ci);
			
		return count/(double) dataList.size();
		
		
	}
	

	public static double Count(ArrayList<Case> dataList, Attribute x, String outcome) {
		

		Iterator<Case> myIt=dataList.iterator();
		double count=0;
		
		
		while(myIt.hasNext()) {
			
			if(myIt.next().getValue(x.getAName()).equals(outcome)) {
				count++;
			}
		}//while

		return count;
		
	}//Count


}
